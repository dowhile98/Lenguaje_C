/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2022 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */

#include <stdint.h>

#define GPIOA_BASE_ADDR	0x40020000
#define GPIOC_BASE_ADDR 0x40020800
#define RCC_BASE_ADDDR	0x40023800

#define __vo volatile
/*
 * Note : Registers of a peripheral are specific to MCU
 * e.g : Number of Registers of SPI peripheral of STM32F4x family of MCUs may be different(more or less)
 * Compared to number of registers of SPI peripheral of STM32Lx or STM32F0x family of MCUs
 * Please check your Device RM
 */

typedef struct
{
	__vo uint32_t MODER;                        /*!< GPIO port mode register,                    	Address offset: 0x00      */
	__vo uint32_t OTYPER;                       /*!< TODO,     										Address offset: 0x04      */
	__vo uint32_t OSPEEDR;
	__vo uint32_t PUPDR;
	__vo uint32_t IDR;
	__vo uint32_t ODR;
	__vo uint32_t BSRR;
	__vo uint32_t LCKR;
	__vo uint32_t AFR[2];					 /*!< AFR[0] : GPIO alternate function low register, AF[1] : GPIO alternate function high register    		Address offset: 0x20-0x24 */
}GPIO_RegDef_t;

typedef struct{
	uint32_t pin0	:1;
	uint32_t pin1	:1;
	uint32_t pin2	:1;
	uint32_t pin3	:1;
	uint32_t pin4	:1;
	uint32_t pin5	:1;
	uint32_t pin6	:1;
	uint32_t pin7	:1;
	uint32_t pin8	:1;
	uint32_t pin9	:1;
	uint32_t pin10	:1;
	uint32_t pin11	:1;
	uint32_t pin12	:1;
	uint32_t pin13	:1;
	uint32_t pin14	:1;
	uint32_t pin15	:1;
}GPIO_ODR_t;



void delay(uint32_t delay){
	for(uint32_t i= 0;i<delay;i++){
		for(uint32_t j = 0;j<1000;j++);
	}
}
int main(void)
{
	volatile uint32_t *RCC_AHB1ENR = (volatile uint32_t*)(RCC_BASE_ADDDR + 0x30);
	volatile uint32_t *GPIOA_MODER = (volatile uint32_t*)(GPIOA_BASE_ADDR + 0x00);
	volatile uint32_t *GPIOA_ODR = (volatile uint32_t*)(GPIOA_BASE_ADDR + 0x14);

	GPIO_RegDef_t *pGPIOA = (GPIO_RegDef_t*)(GPIOA_BASE_ADDR);
	GPIO_ODR_t volatile *pODRA = (GPIO_ODR_t *)(GPIOA_BASE_ADDR + 0x14);
	//PA5-> SALIDA

	*RCC_AHB1ENR |= 1<<0;			//HABILITAR EL RELOJ
	*GPIOA_MODER &=~ (0xFU<<2*5);	//RESET
	*GPIOA_MODER |= 1U<<2*5;		//SALIDA
	pGPIOA->MODER |= 1U;
	*GPIOA_ODR |= 1U;
    /* Loop forever */
	for(;;){
		pODRA->pin5 = 1;
		delay(500);
		pODRA->pin5 = 0;
		delay(500);
	}
}
